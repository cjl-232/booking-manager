<!-- datetime feeding done, but now need to completely review how async stuff is done! Learn it carefully -->

<!DOCTYPE html>
<html>
  <head>
    <title>Desk Booking</title>
    <meta charset="utf-8">
    <meta content="width = device-width, initial-scale = 1" name="viewport">
    {% load static %}
    {% load compress %}
    <link rel="stylesheet" href="{% static 'jquery.datetimepicker.css' %}"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <link href="{% static 'stylesheet.css' %}" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/vanillajs-datepicker@1.3.4/dist/js/datepicker-full.js" integrity="sha384-BBTxy78shItxVf6Hz4VlUqO0A+B1lgtfSgFCwrn3Xb95oVD5LNI1qrqMceSZ+w+7" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js" integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r" crossorigin="anonymous"></script>
    <script src="{% static 'jquery.js' %}"></script>
    <script src="{% static 'jquery.datetimepicker.full.js' %}"></script>
  </head>
  <body>
    <div class="container">
      <div class="row">
        <div class="col" style="min-width: 340px; max-width: 340px;">
          <form>
            <div class="form-group">
              <div for="site_selection" class="form-label">Select location:</div>
              <select id="site_selection" class="form-select">
                {% for site in sites %}
                  {% if forloop.first %}
                    <option selected value="{{site.id}}" label="{{site.name}}">
                  {% endif %}
                  {% if not forloop.first %}
                    <option value="{{site.id}}" label="{{site.name}}">
                  {% endif %}
                {% endfor %}
                <option value="kirby" label="Kirby">
              </select>
            </div>
            <div class="form-group">
              <div for="start_datetime" class="form-label">Select booking start:</div>
              <input type="text" id="start_datetime" class="form-control">
            </div>
            <div class="form-group">
              <div for="end_datetime" class="form-label">Select booking end:</div>
              <input type="text" id="end_datetime" class="form-control">
            </div>
          </form>
        </div>
        <div class="col">
          <form>
            <div class="form-group">
              <div id="date_range" for="canvas" class="form-label"></div>
              <canvas id="canvas" height="600" width="1200"></canvas>
            </div>
            <div id="floor_buttons" class="btn-group btn-group-toggle">  
              
            </div>
          </form>
        </div>
       </div>
    </div>
  
    <!-- Date/time picker initialisation: -->
    <script>
      jQuery(function(){
      
        function same_date(lhs, rhs) {
          return lhs.getDate() == rhs.getDate() && lhs.getMonth() == rhs.getMonth() && lhs.getFullYear() == rhs.getFullYear();
        };
        
        function format_date(date) {
          [year, month, day, hour, minute] = [
            date.getFullYear(),
            date.getMonth() + 1,
            date.getDate(),
            date.getHours(),
            date.getMinutes(),
          ];
          date_component = [
            year, 
            month.toString().padStart(2, '0'), 
            day.toString().padStart(2, '0'),
          ].join('-');
          time_component = [
            hour.toString().padStart(2, '0'),
            minute.toString().padStart(2, '0'),
          ].join(':');
          return date_component + " " + time_component;
        };
        
        function get_date_range_text() {
          var result = "Availability from ";
          result += format_date($("#start_datetime").datetimepicker('getValue'));
          result += " to "; 
          result += format_date($("#end_datetime").datetimepicker('getValue'));
          result += ":"
          return result;
        };      
       
        jQuery("#start_datetime").datetimepicker({
          format: 'Y-m-d h:m',
          inline: true,
          step: 30,
          minDate: 0,
          defaultTime: '09:00',
          onChangeDateTime: function(datetime) {
            
            datetime.setMinutes(30 * Math.floor(datetime.getMinutes() / 30), 0);
            
            const end_datetime = $('#end_datetime').datetimepicker('getValue');
            const min_end_datetime = new Date(datetime);
            min_end_datetime.setMinutes(min_end_datetime.getMinutes() + 30);
                                
            $("#end_datetime").datetimepicker("setOptions", {
              minDate: min_end_datetime,
              minTime: same_date(datetime, min_end_datetime) ? min_end_datetime : false,
              value: (end_datetime < min_end_datetime) ? min_end_datetime : null,
            });
            $('#date_range').text(get_date_range_text());
          }
        });
        
        jQuery("#end_datetime").datetimepicker({
          inline: true,
          step: 30,
          minDate: 0,
          defaultTime: '17:30',
          onChangeDateTime: function(datetime) {
          
            datetime.setMinutes(30 * Math.floor(datetime.getMinutes() / 30), 0);
            
            const start_datetime = $('#start_datetime').datetimepicker('getValue');
            const max_start_datetime = new Date(datetime);
            max_start_datetime.setMinutes(max_start_datetime.getMinutes() - 30);
            
            const min_end_datetime = new Date(start_datetime);
            min_end_datetime.setMinutes(min_end_datetime.getMinutes() + 30);

            $("#end_datetime").datetimepicker("setOptions", {
              minDate: min_end_datetime,
              minTime: (same_date(datetime, min_end_datetime)) ? min_end_datetime : false,
              value: (datetime < min_end_datetime) ? min_end_datetime : null
            });
            $('#date_range').text(get_date_range_text());
          }
        });
        
        
        
        $('#date_range').text(get_date_range_text());
      });
      
    </script>
    
    <!-- Canvas and floor button group code: -->
    {% compress js %}
    <script>
   
      //Have an async for loading the background that has to be awaited.
   
      //May need to reconsider this approach. Asynchronous events are...
      //well, asynchronous.
      
      //
      
      //What needs to happen is:
      //Load and draw the floor image
      //Only AFTER this: iterate through each desk, draw rectangles, note down
      //the coordinates of active desks in one promise.all thing
      //iterate through that and set up clickable areas accordingly
      
      //NEED TO ENSURE IMAGE STRETCHING IS APPLIED TO BOX POSITIONS
      //MULTIPLY BY CANVAS SIZE, DIVIDE BY IMAGE SIZE?
      
      
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const site_selection = document.getElementById('site_selection');
      const floor_buttons = document.getElementById('floor_buttons');
      const plan_image = document.createElement('img');
      let width_ratio = 1.0;
      let height_ratio = 1.0;

      async function updatePlanImage(url) {
        
        plan_image.src = '{% get_media_prefix %}' + url;
        width_ratio = canvas.width / plan_image.naturalWidth;
        height_ratio = canvas.height / plan_image.naturalHeight;
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(plan_image, 0, 0, canvas.width, canvas.height);
      };
      
      function loadDesks(floor_id) {
      
        //Define a function to check if a desk object meets desired criteria:
        function deskMeetsCriteria(desk) {
          return true;
        };
        
        //Define a function to draw a desk given a desk object and colour:
        function drawDesk(desk, colour) {
          ctx.translate(
              width_ratio * (desk.x_position + desk.width / 2), 
              height_ratio * (desk.y_position + desk.height / 2),
            );
            ctx.rotate(desk.angle * Math.PI / 180);
            ctx.fillStyle = colour;
            ctx.fillRect(
              -width_ratio * desk.width / 2,
              -height_ratio * desk.height / 2, 
              width_ratio * desk.width,
              height_ratio * desk.height,
            );
            ctx.strokeRect(
              -width_ratio * desk.width / 2,
              -height_ratio * desk.height / 2, 
              width_ratio * desk.width,
              height_ratio * desk.height,
            );
            ctx.fillStyle = "black";
            ctx.fillText(desk.name, 0, 0);
            ctx.restore();
        };
        const start_datetime = $('#start_datetime').datetimepicker('getValue');
        const end_datetime = $('#end_datetime').datetimepicker('getValue');
        const url = "{% url 'index' %}" + "api/desks/" + floor_id;
        fetch(
          url,
          {
            method: "GET", 
            headers: { "X-Requested-With": "XMLHttpRequest" },
          },
        )
        .then(response => response.json())
        .then(data => {
          //Set up the context to draw with desired aesthetics:
          ctx.strokeStyle = "black";
          ctx.font = "24px arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.save();
          
          //Iterate over retrieved desks and draw each:
          for (const desk of data.desks) {
            if (deskMeetsCriteria(desk)) {
              let url = "{% url 'index' %}" + "api/bookings/" + desk.id;
              url += "/" + start_datetime.toISOString();
              url += "/" + end_datetime.toISOString();
              fetch(
                url,
                {
                    method: "GET", 
                    headers: { "X-Requested-With": "XMLHttpRequest" },
                }
              )
              .then(response => {
                return response.json();
              })
              .then(data => {
                if (data.bookings.length == 0) {
                  drawDesk(desk, 'green');
                } else {
                  drawDesk(desk, 'red');
                };
              });
            } else {
              drawDesk(desk, "grey");
            };
          }
        })
      };

      async function refreshCanvas(e) {

        //Retrieve the relevant plan image url and render it:
        console.log(document.querySelector("input[name='floor_buttons']:checked"));
        await updatePlanImage(
          document.querySelector('input[name="floor_buttons"]:checked').value
        );
        
        //Retrieve the id of the selected floor:
        const floor_id = document.querySelector(
          'input[name="floor_buttons"]:checked'
        ).id.substring(13);
        
        //Load desk items from the specified floor:
        loadDesks(floor_id);
      }

      function loadFloorButtons(e) {
        const site_id = site_selection.value;
        const url = "{% url 'index' %}" + "api/floors/" + site_id;
        fetch(
          url,
          {
              method: "GET", 
              headers: { "X-Requested-With": "XMLHttpRequest" },
          },
        )
        .then(response => response.json())
        .then(data => {
          floor_buttons.replaceChildren();
          for (let i = 0; i < data.floors.length; i++) {
            let btn = document.createElement('input');
            btn.type = 'radio';
            btn.name = 'floor_buttons';
            btn.id = 'floor_button_' + data.floors[i].id;
            btn.value = data.floors[i].plan;
            if (i == 0) {
              btn.checked = true;
              btn.classList.add('checked');
            };
            btn.addEventListener('click', function(e) {
              for (var sibling of this.parentNode.children) {
                sibling.classList.remove('checked');
              };
              this.classList.add('checked');
              refreshCanvas(e);
            });
            console.log(btn);
            floor_buttons.appendChild(btn);
          };
        });
      };
      
      jQuery(function(){
        site_selection.addEventListener('change', loadFloorButtons);
      });
      
      jQuery(function(){
        
        loadFloorButtons();
        console.log("debug2");
        console.log(floor_buttons);
        
      });
      
      jQuery(function(){
        
        refreshCanvas();
        
      });
  
    </script>
    {% endcompress %}

    
    <!-- Floor button group code: -->
    
    
    
  </body>
</html>